import com.cliabhach.terrapin.gradle.ParentCopyJsToNodeModules
import org.jetbrains.kotlin.gradle.targets.js.ir.KotlinJsIrLink
import org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootExtension
import org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootPlugin
import org.jetbrains.kotlin.gradle.targets.js.npm.tasks.KotlinPackageJsonTask

import java.util.concurrent.atomic.AtomicReference

plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '1.6.20-M1' apply false
    id 'org.jetbrains.kotlin.plugin.serialization' version '1.6.20-M1' apply false
}

group = 'com.cliabhach.terrapin'
version = '1.0'

// Use host-provided NodeJS instead of downloading our own copy
//noinspection GroovyAssignabilityCheck
plugins.withType(NodeJsRootPlugin) {
    NodeJsRootExtension ext = extensions.getByType(NodeJsRootExtension)
    //noinspection GroovyAssignabilityCheck
    ext.download = false
}


// Try to register a special task for Kotlin/JS modules
def rootProjectName = project.name.toLowerCase(Locale.ROOT)

TaskProvider rootTaskProvider = project.tasks.register(
        "copyJsToNodeModules",
        ParentCopyJsToNodeModules,
        ParentCopyJsToNodeModules::configureAgainstProject
)

subprojects {

    // tasks.all and tasks.withType are lazily evaluated, but tasks.getByName
    // and tasks.named aren't.
    Provider<Task> packageJsonTaskProvider = providePackageJsonTask(project)

    tasks.withType(KotlinJsIrLink) { Task outputsJsFilesTask ->

        // Looking for "compileProductionExecutableKotlinJs"
        if (ParentCopyJsToNodeModules.matches(
                outputsJsFilesTask, "production", "executable"
        )) {

            // If the line below never executes, not for ANY of the subprojects
            // (because none of them match our conditions), then we never
            // create these copy tasks.
            ParentCopyJsToNodeModules parentTask = rootTaskProvider.get()
            parentTask.registerChildCopyTask(
                    project,
                    outputsJsFilesTask,
                    rootProjectName,
                    packageJsonTaskProvider
            )
        }
    }
}

private static Provider<Task> providePackageJsonTask(Project p) {
    AtomicReference<KotlinPackageJsonTask> atomicRef = new AtomicReference<>(null)
    Provider<Task> packageJsonTaskProvider = p.provider(() -> atomicRef.get() as Task)

    p.tasks.withType(KotlinPackageJsonTask) { KotlinPackageJsonTask packageJsonTask ->
        String taskName = packageJsonTask.name
        if (!taskName.containsIgnoreCase("test")) {
            atomicRef.set(packageJsonTask)
        }
    }

    return packageJsonTaskProvider
}
